// ============================================================================
//  * Copyright (c) 2004, 2005 IBM Corporation
//  * All rights reserved. 
//  * This program and the accompanying materials 
//  * are made available under the terms of the BSD License 
//  * which accompanies this distribution, and is available at
//  * http://www.opensource.org/licenses/bsd-license.php
//  * 
//  * Contributors:
//  *     IBM Corporation - initial implementation
// ============================================================================


//
// Copyright 2002,2003,2004  Segher Boessenkool  <segher@kernel.crashing.org>
//

#define NEXT00	goto *cfa->a
#define NEXT0	cfa = ip->a; NEXT00
#define NEXT	ip++; NEXT0

#define PRIM(name) code_##name: { \
		   asm("#### " #name); \
		   void *w = (cfa = (++ip)->a)->a;
#define MIRP	   goto *w; }



	// start interpreting
	NEXT0;



// These macros could be replaced to allow for TOS caching etc.
#define TOS (*dp)
#define NOS (*(dp-1))
#define POP dp--
#define PUSH dp++

#define RTOS (*rp)
#define RNOS (*(rp-1))
#define RPOP rp--
#define RPUSH rp++




// For terminal input.
PRIM(TIB) PUSH; TOS.a = the_tib; MIRP

// For pockets (temporary string buffers).
PRIM(POCKETS) PUSH; TOS.a = the_pockets; MIRP



// Codefields.
code_DOCOL:
	{
		RPUSH; RTOS.a = ip;
		ip = cfa;
		NEXT;
	}
code_DODOES:
	{
		RPUSH; RTOS.a = ip;
		ip = (cfa + 1)->a;
		PUSH; TOS.a = cfa + 2;
		NEXT0;
	}
code_DODEFER:
code_DOALIAS:
	{
		cfa = (cfa + 1)->a;
		NEXT00;
	}
code_DOCON:
code_DOVAL:
	{
		PUSH;
		TOS = *(cfa + 1);
		NEXT;
	}
code_DOFIELD:
	{
		dp->n += (cfa + 1)->n;
		NEXT;
	}
code_DOVAR:
code_DOBUFFER_X3a:
	{
		(++dp)->a = cfa + 1;
		NEXT;
	}





// branching
code_BRANCH:
	{
		type_n dis = (++ip)->n;
		ip = (cell *)((type_u)ip + dis);
		NEXT;
	}
code_0BRANCH:
	{
		type_n dis = (++ip)->n;
		if (TOS.u == 0)
			ip = (cell *)((type_u)ip + dis);
		POP;
		NEXT;
	}



// literals
code_LIT:
code_DOTICK:
	{
		PUSH;
		TOS = *++ip;
		NEXT;
	}



// 1.1
PRIM(DUP) cell x = TOS; PUSH; TOS = x; MIRP
PRIM(OVER) cell x = NOS; PUSH; TOS = x; MIRP
PRIM(PICK) TOS = *(dp - TOS.n - 1); MIRP

// 1.2
PRIM(DROP) POP; MIRP

// 1.3
PRIM(SWAP) cell x = NOS; NOS = TOS; TOS = x; MIRP

// 1.4
PRIM(_X3e_R) RPUSH; RTOS = TOS; POP; MIRP
PRIM(R_X3e) PUSH; TOS = RTOS; RPOP; MIRP
PRIM(R_X40) PUSH; TOS = RTOS; MIRP

// 1.5
PRIM(DEPTH) PUSH; TOS.u = dp - the_data_stack; MIRP
PRIM(DEPTH_X21) dp = the_data_stack + TOS.u - 1; MIRP
PRIM(RDEPTH) PUSH; TOS.u = rp - the_return_stack + 1; MIRP
PRIM(RDEPTH_X21) rp = the_return_stack + TOS.u - 1; POP; MIRP

// 2.1
PRIM(_X2b) NOS.u += TOS.u; POP; MIRP
PRIM(_X2d) NOS.u -= TOS.u; POP; MIRP
PRIM(_X2a) NOS.u *= TOS.u; POP; MIRP

// 2.2
PRIM(LSHIFT) NOS.u <<= TOS.u; POP; MIRP
PRIM(RSHIFT) NOS.u >>= TOS.u; POP; MIRP
PRIM(ASHIFT) NOS.n >>= TOS.u; POP; MIRP
PRIM(AND) NOS.u &= TOS.u; POP; MIRP
PRIM(OR) NOS.u |= TOS.u; POP; MIRP
PRIM(XOR) NOS.u ^= TOS.u; POP; MIRP

// 3.1
#define GET_TYPE1(t) { \
		t *restrict a = (t *restrict)(TOS.a); \
		t b;

#define GET_TYPE2(t) \
		b = *a;

#define GET_TYPE3(t) \
		TOS.u = b; \
}

#define PUT_TYPE1(t) { \
		t *restrict a = TOS.a; \
		t b = NOS.u; \
		POP; \
		POP;

#define PUT_TYPE2(t) \
		*a = b; \
}

#define GET_CELL1 GET_TYPE1(type_u)
#define PUT_CELL1 PUT_TYPE1(type_u)
#define GET_CHAR1 GET_TYPE1(type_c)
#define PUT_CHAR1 PUT_TYPE1(type_c)
#define GET_WORD1 GET_TYPE1(type_w)
#define PUT_WORD1 PUT_TYPE1(type_w)
#define GET_LONG1 GET_TYPE1(type_l)
#define PUT_LONG1 PUT_TYPE1(type_l)
#define GET_XONG1 GET_TYPE1(type_u)
#define PUT_XONG1 PUT_TYPE1(type_u)

#define GET_CELL2 GET_TYPE2(type_u)
#define PUT_CELL2 PUT_TYPE2(type_u)
#define GET_CHAR2 GET_TYPE2(type_c)
#define PUT_CHAR2 PUT_TYPE2(type_c)
#define GET_WORD2 GET_TYPE2(type_w)
#define PUT_WORD2 PUT_TYPE2(type_w)
#define GET_LONG2 GET_TYPE2(type_l)
#define PUT_LONG2 PUT_TYPE2(type_l)
#define GET_XONG2 GET_TYPE2(type_u)
#define PUT_XONG2 PUT_TYPE2(type_u)

#define GET_CELL3 GET_TYPE3(type_u)
#define GET_CHAR3 GET_TYPE3(type_c)
#define GET_WORD3 GET_TYPE3(type_w)
#define GET_LONG3 GET_TYPE3(type_l)
#define GET_XONG3 GET_TYPE3(type_u)

#define GET_CELL GET_CELL1 GET_CELL2 GET_CELL3
#define PUT_CELL PUT_CELL1 PUT_CELL2
#define GET_CHAR GET_CHAR1 GET_CHAR2 GET_CHAR3
#define PUT_CHAR PUT_CHAR1 PUT_CHAR2
#define GET_WORD GET_WORD1 GET_WORD2 GET_WORD3
#define PUT_WORD PUT_WORD1 PUT_WORD2
#define GET_LONG GET_LONG1 GET_LONG2 GET_LONG3
#define PUT_LONG PUT_LONG1 PUT_LONG2
#define GET_XONG GET_XONG1 GET_XONG2 GET_XONG3
#define PUT_XONG PUT_XONG1 PUT_XONG2

	PRIM(_X40)  GET_CELL; MIRP
	PRIM(_X21)  PUT_CELL; MIRP
	PRIM(C_X40) GET_CHAR; MIRP
	PRIM(C_X21) PUT_CHAR; MIRP
	PRIM(W_X40) GET_WORD; MIRP
	PRIM(W_X21) PUT_WORD; MIRP
	PRIM(L_X40) GET_LONG; MIRP
	PRIM(L_X21) PUT_LONG; MIRP
	PRIM(X_X40) GET_XONG; MIRP
	PRIM(X_X21) PUT_XONG; MIRP



// 6
PRIM(_X3c) NOS.n = -(NOS.n < TOS.n); POP; MIRP
PRIM(U_X3c) NOS.n = -(NOS.u < TOS.u); POP; MIRP
PRIM(0_X3c) TOS.n = -(TOS.n < 0); MIRP
PRIM(_X3d) NOS.n = -(NOS.u == TOS.u); POP; MIRP
PRIM(0_X3d) TOS.n = -(TOS.u == 0); MIRP






// 8.4
PRIM(DODO) RPUSH; RTOS = NOS; RPUSH; RTOS = TOS; POP; POP; MIRP
code_DO_X3f_DO:
	{
		cell i = *dp--;
		cell n = *dp--;
		type_n dis = (++ip)->n;
		if (i.n == n.n)
			ip = (cell *restrict)((type_c *restrict)ip + dis);
		else {
			*(rp + 1) = n;
			*(rp += 2) = i;
		}
		NEXT;
	}
code_DOLOOP:
	{
		type_n dis = (++ip)->n;
		rp->n++;
		if (rp->n == (rp - 1)->n)
			rp -= 2;
		else
			ip = (cell *restrict)((type_c *restrict)ip + dis);
		NEXT;
	}
code_DO_X2b_LOOP:
	{
		type_u lo, hi;
		type_n inc;
		type_n dis = (++ip)->n;
		lo = rp->u;
		inc = (dp--)->n;
		rp->n += inc;
		if (inc >= 0)
			hi = rp->u;
		else {
			hi = lo;
			lo = rp->u;
		}
		if ((type_u)((rp - 1)->n - 1 - lo) < hi - lo)
			rp -= 2;
		else
			ip = (cell *restrict)((type_c *restrict)ip + dis);
		NEXT;
	}
code_DOLEAVE:
	{
		type_n dis = (++ip)->n;
		rp -= 2;
		ip = (cell *restrict)((type_c *restrict)ip + dis);
		NEXT;
	}
code_DO_X3f_LEAVE:
	{
		type_n dis = (++ip)->n;
		if ((dp--)->n) {
			rp -= 2;
			ip = (cell *restrict)((type_c *restrict)ip + dis);
		}
		NEXT;
	}






// 8.5
code_EXIT:
	{
		ip = (rp--)->a;
		NEXT;
	}
code_EXECUTE:	// don't need this as prim
	{
		cfa = (dp--)->a;
		NEXT00;
	}




// 3.1
PRIM(MOVE)
	type_u n = TOS.u; POP;
	unsigned char *q = TOS.a; POP;
	unsigned char *p = TOS.a; POP;
	if (p >= q || q >= p + n)
		for (p--, q--; n--; )
			*++q = *++p;
	else
		for (p += n, q += n ; n--; )
			*--q = *--p;
MIRP


PRIM(FLUSHCACHE)
	type_u n = TOS.u; POP;
	unsigned char* p = TOS.a; POP;
	flush_cache(p, n);	
MIRP
